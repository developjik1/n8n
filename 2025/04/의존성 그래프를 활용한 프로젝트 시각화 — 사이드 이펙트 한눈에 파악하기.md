# 🎯 의존성 그래프를 활용한 프로젝트 시각화 — 사이드 이펙트 한눈에 파악하기

> 🕒 **발행일:** Thu, 10 Apr 2025 06:26:29 GMT  
> 🔗 **원본 링크:** [👉 바로 가기](https://medium.com/daangn/%EC%9D%98%EC%A1%B4%EC%84%B1-%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-%ED%95%9C%EB%88%88%EC%97%90-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0-eec17d5aabb2?source=rss----4505f82a2dbd---4)

---

## 📌 **핵심 요약**  
📖 ### 의존성 그래프를 활용한 프로젝트 시각화 — 사이드 이펙트 한눈에 파악하기

안녕하세요! 당근의 동네 지도 탭에서 확인할 수 있는 동네 가게 화면과 동네 사장님들이 가게를 관리하기 위한 비즈니스 도구를 만드는 로컬 비즈니스의 Frontend Engineer 준(Joon)이에요.

혹시 ‘줄줄이 고구마’라는 말을 들어보신 적 있으신가요? 고구마 하나를 캐니, 그 뿌리에 달린 다른 고구마들이 몇 십 개나 딸려 나왔다는 건데요. 고구마가 70개나 달린 줄줄이 고구마 사진을 뉴스에서 처음 봤을 때, 저는 제가 작업하던 코드가 생각나더라고요.

많은 엔지니어들이 그러하듯, 저도 개발에 착수하기 전에 일정을 산정하는데요. 정작 작업하다 보면 예상치 못한 사이드 이펙트가 ‘하나 캐니 줄줄줄!’ 나오는 상황이 발생하곤 하죠. 그럴 때마다 ‘고구마 뿌리 뽑듯이 계속 나와서요.. 🥺’라고 공유드리며 일정을 미룬 적이 한두 번이아니에요. 이러면 팀 차원의 일정이 미뤄지기 때문에 그 해결 방법을 고민하기 시작했어요.

결과적으로 저희 팀은 의존성 그래프를 활용해 프로젝트를 시각화함으로써 코드 파악에 소모되는 시간을 단축했어요. 덕분에 팀에서는 불필요한 리소스 소모 없이 더 빠른 실행이 가능해졌는데요. 이 글에서는 그 구체적인 과정을 소개해 드리려고 해요. 본격적인 작업에 들어가기 전 기존 코드 파악에 시간을 많이 쏟는 게 고민이시라면, 저희의 사례가 업무의 생산성을 높이는 데 큰 도움이 될 수 있을 거예요.

### 문제를 정의해 보자

해결에 앞서 5 whys 기법을 통해 문제의 본질적인 원인을 찾아보려고 했어요.

**Q1: 사이드 이펙트를 왜 뒤늦게 발견하는가?**

A: 일정 산정 시점에는 보이지 않았는데, 코드 작업할 때 눈에 띄는 경우가 많았어요.

**Q2: 일정 산정 시점에는 사이드 이펙트를 찾지 못하는가?**

A: 현실적으로 작업 전에 관련된 모든 파일을 다 뒤져보지 못하기 때문이에요.

**Q3: 왜 작업 관련 파일을 다 뒤져보지 못하는가?**

A: 비즈프로필 웹뷰에는 144개의 페이지, 4648개의 파일이 존재해요. 중간중간 재사용되는 파일을 다 뒤지다 보면, 수작업으로 파악하기 어려울 정도로 경우의 수가 커져요.

5개의 why를 던지지는 않았지만 이쯤에서 저는 본질적인 원인을 파악했다고 판단했어요. **‘너무 많은 파일들의 의존 관계를 다 뒤져보기 힘들다’**는 부분이 해결되면, 예상치 못한 ‘줄줄이 고구마’를 개발 착수 전에 미리 찾아낼 수 있겠다고 생각했죠. 이걸 문제로 정의하고 해결해 보기로 했어요.

### 어떻게 해결하는 게 좋을까?

앞에서 정의한 문제는 다음과 같아요.

> **_‘너무 많은 파일들의 의존 관계를 다 뒤져보기 힘들다’_**

이 문제는 두 가지 방식으로 접근할 수 있을 것 같아요.

1. **설계 잘하기** : 파일 간의 관계를 명확하게 드러낼 수 있는 폴더 구조 혹은 아키텍처를 정립한다.
2. **시각화 잘하기** : 현재 파일이 어떤 파일을 import 하고 있는지, 어떤 파일에 import 되고 있는지 한눈에 볼 수 있도록 시각화한다.

1번은 의존 관계의 복잡도 자체를 근본적으로 낮출 수 있는 방법이에요. 그러나 빠르게 프로덕트를 실험하고 기능을 추가하고자 하는 상황에서 한 가지 구조를 학습시키고 따르게 하는 것은 많은 설득과 시간이 필요할 거예요. 따라서 1번은 장기적으로 가져가야 할 전략이라 판단했고, 당장 지금의 문제를 완화할 수 있는 방안으로 시각화를 잘해보자는 결론에 다다랐어요.

JS/TS 환경에서 사용할 수 있는 의존성 시각화 도구로 크게 두 가지 정도를 발견했어요.

* [Madge](https://github.com/pahen/madge)
* [Dependency Cruiser](https://github.com/sverweij/dependency-cruiser/tree/main)

저는 이 중에서 조금 더 문서화가 잘 되어 있는 Dependency Cruiser를 사용하기로 했어요. 이 도구를 사용하면 다음과 같은 의존성 그래프를 그릴 수 있어요.

![](https://cdn-images-1.medium.com/max/1024/1*sK4g4seXlehCtKRUF2EM7Q.png)

참고로, 이 글에서는 도구의 사용법은 다루지 않을 예정이에요. 어떤 도구를 사용하든 파일 구조에 따라 정규표현식을 각기 다르게 써주어야 하고, 보고 싶은 정보가 사람, 팀, 상황마다 다를 수 있어요. 그래서 툴보다는 의존성 그래프 활용 사례를 중심으로 소개해 드릴 예정이에요.

> _Tip: Cursor의 Docs에 추가하거나 GPT에 링크를 넣고 물어보면, 훨씬 빠르게 원하는 옵션을 찾을 수 있어요._

### 의존성 그래프를 적용해 보자

개발을 하다 보면 코드를 파악해야 하는 상황이 정말 많이 벌어지는데요. 의존성 그래프가 어떻게 코드 파악을 용이하게 만드는지 DashBoard, Profile, Settings 3개의 페이지를 가진 예제 프로젝트를 기준으로 설명드려볼게요.

![](https://cdn-images-1.medium.com/max/1024/1*IE9QROkgKtmjo_jUXA_Dsw.png)

예제 프로젝트 — DashBoard 페이지

### Bottom-Up: 이 파일의 사이드 이펙트를 빠르게 알고 싶어.

협업을 하다 보면 종종 디자이너 분들에게서 이런 요청을 받을 때가 있어요.

> _👩‍🎨(디자이너) : 공통 컴포넌트를 디자인시스템으로 만들기 위해 파악 중이에요. 혹시 카드 컴포넌트가 어디 어디 쓰이는지 알 수 있을까요?_

혹은 본격적으로 개발하기 전에 수정해야 할 파일의 사이드 이펙트를 파악해야 하죠.

> _🧑‍💻(엔지니어) : 이번 작업은 카드 컴포넌트 리팩토링이 수반될 것 같은데, 이 작업이 어느 파일들에 영향을 줄까?_

의존성 그래프를 도입하기 전과 후의 작업 과정을 한번 비교해 볼게요.

**Before: 파일을 하나하나 타고 올라가서 파악했어요**

기존에는 위와 같은 요청을 받으면 일단 에디터에서 카드 컴포넌트 파일(Card.tsx)을 여는 걸로 시작했어요. 그 후 Cmd(혹은 Ctrl) 버튼을 누른 채 컴포넌트명을 누르면, 아래 이미지와 같이 이 컴포넌트가 어디에서 import 되는지 목록을 볼 수 있죠.

![](https://cdn-images-1.medium.com/max/1024/1*YQkER8vjEgBIiMuLpneX1Q.png)

여기를 보면 다음과 같은 파일들이 보이네요.

* components/.../UserProfile.tsx
* components/.../ActivityList.tsx
* components/.../StatCard.tsx
* components/.../NotificationSettings.tsx
* components/.../UserProfileCard.tsx
* pages/Dashboard.tsx
* pages/Settings.tsx

일단 pages/Dashboard.tsx, pages/Settings.tsx 두 페이지에서 쓰인다는 사실은 알았으니 나머지 컴포넌트들은 어느 페이지에서 쓰이는지 봐야 해요. UserProfile.tsx를 import하고 있는 파일 목록 안에, 그 파일들을 import 하고 있는 파일 목록을 또 파악하고, 그 과정 끝에 최종적으로 import 하고 있는 페이지 컴포넌트를 확인해야 하죠.

이 과정을 ActivityList.tsx, StatCard.tsx, NotificationSettings.tsx, UserProfileCard.tsx 각각에 대하여 재귀적으로 다 확인해 본 다음에야 비로소 카드 컴포넌트가 사용되는 영향 범위를 전부 알 수 있어요. 수백, 수천 개의 파일이 서로 의존하고 있는 프로젝트에선 길게는 수시간 이상 걸리기도 하는 과정이에요.

**After: 의존성 그래프를 그려 한눈에 파악해요**

다음 옵션들과 함께 Dependency Cruiser 스크립트 실행하면 이런 그래프를 그릴 수 있어요.

* depcruise src : 타겟 경로로 src를 넣어 전체 소스 코드에 대한 의존성 그래프를 그려요.
* \--reaches 옵션으로, 카드 컴포넌트에 도달하는 의존성만 필터링해서 원하는 정보만 남겼어요.
* \--highlight 옵션으로, pages와 카드 컴포넌트를 한눈에 알아볼 수 있게 색을 입혔어요.
* \--include-only 옵션으로, src 경로에서만 의존성을 파악하도록 했어요. (node\_modules 제외)

![](https://cdn-images-1.medium.com/max/1024/1*CDSiyltcDCQRHA3iBYtwgQ.png)

이렇게 생성된 의존성 그래프를 보면, Card 컴포넌트가 사용되고 있는 페이지를 한눈에 파악할 수 있어요. 이제는 스크립트 한번 실행하는 것만으로 파일을 하나하나 찾아볼 시간이 절약되었고, 덤으로 DashLayout, SettingsLayout는 아무 페이지에서도 안 쓰고 있다는 것을 발견했네요.

또한 실무에서 협업할 때도 확실한 이점을 느꼈는데요. 본 작업 전에 코드 리팩토링 작업이 필요하다는 사실을 비개발 직군 팀원들에게 설득할 때, 복잡하게 그려진 의존성 그래프를 보여주면 문제를 더 직관적으로 이해시킬 수 있게 됐어요.

### Top-Down: 이 컴포넌트가 어떤 파일에 영향받는지 궁금해.

앞에서는 특정 파일이 **‘어디에 사용되는지’**에 대한 궁금증을 해소하기 위해 의존성 그래프의 도움을 받았어요. 이번에는 특정 파일이 **‘무엇을 사용하는지’** 궁금한 경우에 대해서 이야기해보려고 해요.

대표적으로 프로젝트에서 처음 수정해 보는 페이지를 마주치게 된다면, 다음과 같은 생각이 자연스럽게 따라 나오는 것 같아요.

> _👨‍💻(엔지니어) : DashBoard 페이지는 처음 건드려보는데, 얼마나 복잡한 페이지일까?_

DashBoard 페이지를 작업하기 전에 예상 소요 시간을 파악하기 위해서는 주요 파일들을 한번 훑어보는 과정이 반드시 필요하죠. 의존성 그래프를 도입하기 전후로 이 과정에 어떤 변화가 있었는지 소개드려볼게요.

**Before: 코드를 보고 눈대중으로 중요한 부분만 파악했어요**

일단 pages/Dashboard.tsx 에 들어가서 코드를 훑어본 다음, 중요해 보이는 컴포넌트나 훅이 있다면 해당 파일로 가서 세부 구현을 살펴봐요.

그렇게 들어간 파일에서도 핵심 로직을 집중적으로 보고, 나머지 코드에서도 중요해 보이는 파일이 있다면 또 넘어가서 보는 것을 반복했어요. 이 페이지가 가진 복잡도가 어느 정도인지 눈대중으로 감을 얻어갔죠.

이 과정에서 느낀 불편함은 다음과 같아요.

* **시간 소모** : 복잡한 페이지일수록 수십 개의 컴포넌트를 일일이 확인해야 하는데, 많게는 몇 시간까지 소요돼요. 게다가 중간중간 질문을 받거나 회의를 다녀오면 집중이 끊기기 때문에 더 많은 시간을 필요로 해요.
* **중복 파악 / 누락 가능성** : 중첩된 컴포넌트 구조에서는 일부를 놓치거나 봤던 파일을 또 보기 쉬워요. 또한 추상화로 인해 숨겨진 내부 동작을 모르고 어림짐작으로 넘어간다면, 작업할 때 뒤늦게 발견되는 코드로 인해 일정에 변수가 생기기도 해요.
* **일정 산정의 근거 미약 :** 이렇게 파악한 결론은 ‘복잡한 것 같다는 감’이기 때문에, “이 페이지는 다른 데보다 조금 더 복잡해서 일정이 더 필요할 거 같아요” 정도의 두루뭉술한 소통이 일어날 수 있어요. 일정이 지연됐을 때 “막상 작업하다 보니 생각보다 더 복잡해서 일정이 조금 더 필요해요”라고 변명하는 모습은 제가 생각하는 좋은 엔지니어의 모습은 아니었어요.

**After: 하위 의존성을 시각화해, 파일들의 복잡도를 한눈에 파악해요**

Dependency Cruiser는 기본적으로 Top-Down 시각화를 지원해요.

다음 옵션들과 함께 Dependency Cruiser 스크립트 실행하면 이런 그래프를 그릴 수 있어요.

* depcruise src/pages/Dashboard.tsx : 타겟 경로로 Dashboard 파일을 지정하여 Dashboard 페이지 하위 의존성만 그리도록 했어요.
* \--highlight : 대시보드 페이지만 강조하도록 했어요.
* \--collapse : node\_modules에 있는 라이브러리는 최상위 폴더만 보이도록 설정했어요.

![](https://cdn-images-1.medium.com/max/1024/1*cCGdtW12S0FjpnnC-I2hYg.png)

이렇게 Top-Down 방향으로 하위 의존성을 시각화해 보면, Dashboard 페이지 하위에 어떤 파일들이 연관되어 있는지와 얼마나 복잡하게 의존하고 있는지를 한눈에 볼 수 있어요.

의존성 그래프로 인해 앞서 말했던 불편함들이 이렇게 해결돼요.

* **시간 절약 :** Dashboard 페이지 하위의 파일들을 한눈에 보고, 내가 모르는 부분과 이미 아는 부분을 빠르게 솎아낼 수 있어요. 파악할 코드를 추려내기 위해 위에서부터 하나하나 파일을 타고 내려갈 필요 없이 스크립트를 돌리는 몇 초만 소요하면 돼요.
* **중복 파악 / 누락 가능성 감소 :** 파일과 코드를 일일이 텍스트로 보지 않고 관련 파일을 펼쳐놓고 보기 때문에, 봤던 파일을 또 보거나 못 보고 넘어갈 확률이 줄어요.
* **일정 산정의 근거로 활용 :** 개발자만 느끼는 ‘복잡도’라는 개념을 시각적으로 보여주면 비개발자도 쉽게 이해할 수 있어요. 왜 A 페이지를 수정하는 게 왜 B 페이지보다 오래 걸리는지 직관적으로 설명할 수 있어요. 그리고 리팩토링은 복잡도를 낮춰 생산성을 올리는 행위라는 걸 AS-IS / TO-BE로 비교하며 보여줄 수도 있어요.

### Code Review: Pull Request에 의존성 그래프 추가

이번에는 코드리뷰 시점에 의존성 그래프를 적용한 시도를 소개해볼게요.

Github Actions를 이용해 Pull Request에 포함된 File Changes를 기준으로 영향이 가는 범위를 시각화하는 스크립트를 추가했어요. 이 작업으로 인해 저장소에 기여자의 PR이 올라오면, 다음과 같은 시각화가 자동으로 달리게 돼요.

![](https://cdn-images-1.medium.com/max/1024/1*AN7g7lw-smjkyDo333EDag.png)

실제 Pull Request에 생성된 의존성 그래프

기존에는 다른 개발자의 코드를 리뷰할 때 파일 하나, 코드 한 줄이라는 텍스트에 집중했다면, 의존성 시각화를 통해 이 사람이 **얼마나 큰 작업을 했는지,** 수정한 파일의 **사이드 이펙트가 얼마나 큰지를 알 수 있게 되었어요.**

또한 의존성 그래프가 있으면 리뷰어는 다음과 같은 코드리뷰를 통해서 코드베이스 전체의 복잡도까지 관리할 수 있게 돼요.

> _🧑‍💻(리뷰어) : X 파일 수정하셨는데, 작업과 관련 없는 A/B/C 페이지에도 영향이 가는 것 같아요. 예상치 못한 사이드 이펙트가 없도록 리팩토링 먼저 하고 변경사항 적용하면 어떨까요?_

### Team: 프로젝트 전체 구조 한눈에 훑어보기

프로젝트의 신규 기여자를 온보딩할 때, 일반적으로 코드를 살펴보는 시간을 충분히 가지게 하죠.

매일 많은 변경이 일어나는 거대한 프로젝트를 제대로 이해하려면, 그 어떤 문서보다 실제로 돌아가는 코드를 확인하는 게 중요해요. 하지만 수천 개의 파일이 담긴 프로젝트 폴더를 열어보는 순간 어디서부터 봐야 할지 막막해지죠.

이런 막막함을 느껴본 적이 있으시다면 프로젝트 전체를 의존성 그래프로 그려서 지도처럼 표현해 보는 방식을 소개드려요. 다음과 같은 그림이나 스크립트를 기여 문서에 추가한다면, 처음 기여하는 사람들이 조금 더 원활하게 온보딩할 수 있어요.

![](https://cdn-images-1.medium.com/max/1024/1*sK4g4seXlehCtKRUF2EM7Q.png)

예제 프로젝트의 전체 의존성 그래프

기본적으로 depcruise src 로 전체 소스코드를 대상으로 그래프를 그릴 수 있고, Depedency Cruiser 옵션을 더 다양하게 알아보고 건드리면서 필요한 수준으로 조정하시는 걸 추천드려요.

* \--output-type ddot로 폴더 단위로 그래프를 그려 폴더 구조만 표현할 수 있어요.
* 특정 범위의 파일만 보고 싶다면 --include-only로 원하는 영역만 시각화할 수 있어요.
* Rule을 사용하면 순환 참조나 폴더 구조에 대한 규칙을 Lint처럼 걸어두고, 이를 위반한 경우에는 의존성 그래프에 화살표를 강조하는 등의 안내를 줄 수 있어요.

### 결론

의존성 그래프를 활용해 프로젝트 시각화한 후, 코드를 파악하느라 정처 없이 여기저기 파일을 열어보며 돌아다니는 시간이 거의 사라졌어요.

사이드 프로젝트가 아닌 회사 프로젝트에서, 대부분의 개발자는 관리하고 있는 코드의 첫 번째 기여자가 아닌 경우가 많아요. 따라서 코드를 작성하는 것보다 파악하는 시간이 훨씬 길어질 수 있어요.

특히나 제가 당근에서 마주친 코드들은 엔지니어링과 프로덕트 경험 양면에서의 치열한 고민 흔적들이 많이 묻어있었어요. 지금도 옆에서 다양한 고민을 함께 나누고 시도하는 동료들이 있기 때문에 파악할 코드는 더더욱 빠르게 늘어나고 있고요.

Copilot, Cursor 등의 AI 도구들이 발전하면서 코드 작성에 대한 생산성은 빠르게 개선되고 있다고 생각하는데요. 이번 글을 읽으신 분들께서는 의존성 시각화라는 도구를 통해 코드를 파악하는 데에 드는 시간까지 줄여서, 더 빠른 실행과 좋은 프로덕트를 만들어가는 데 조금이라도 도움이 되셨으면 좋겠습니다!

![](https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=eec17d5aabb2)

---

[의존성 그래프를 활용한 프로젝트 시각화 — 사이드 이펙트 한눈에 파악하기](https://medium.com/daangn/%EC%9D%98%EC%A1%B4%EC%84%B1-%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-%ED%95%9C%EB%88%88%EC%97%90-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0-eec17d5aabb2) was originally published in [당근 테크 블로그](https://medium.com/daangn) on Medium, where people are continuing the conversation by highlighting and responding to this story.

---

## 📋 **추가 정보**  
🔹 **게시 날짜:** Thu, 10 Apr 2025 06:26:29 GMT  
🔹 **출처:** [원본 링크](https://medium.com/daangn/%EC%9D%98%EC%A1%B4%EC%84%B1-%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-%ED%95%9C%EB%88%88%EC%97%90-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0-eec17d5aabb2?source=rss----4505f82a2dbd---4)  
🔹 **관련 태그:** #RSS #자동화 #n8n  

---

> ✨ _이 문서는 자동 생성되었습니다. 🚀 Powered by n8n_
